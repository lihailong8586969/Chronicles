

// 为什么可以new自己


// 在JAVA中为什么可以在一个类当中New自己类 例如： public class A{ A a = new A();//为什么可以new自己 }


[原链接](https://zhidao.baidu.com/question/363152743.html)


先问下，问什么不能new自己。
当然，假如按楼主的写法，当这个A第一次被调用的时候，就出抛异常，超出堆栈、内存溢出之类。
楼主，你需要理解“声明”和“实例化”的概念。
A a;
即是声明，创建了一个A类型的变量a
new A();
即是实例化，实实在在地在内存里为A()划分了一块内存空间
a=new A();即是使a指向new A()。以后只要你不更改a的引用，对a的任何操作都会影响到你分配出来的这块内存空间。
理解了这个再回到问题
public class A{}
这个是对类的一个定义，此时，A只是一个“概念”，在电脑里并没有实体存在，但是java的虚拟机（jvm）已经得知了该类的所有定义，就是说，该类被加载进jvm的类加载器（class loader）了，其他的类有可能访问到该A类。
此时A本身就是jvm中的一个类，它自己当然是和自己同包，对不对？
所以A必然可以访问到A
那么public class A{ A a=new A();}
这句话，编译期是正确的，不存在错误，所以可以声明也（被jvm认为）可以实例化。
但是到了运行期，真正的跑起来的时候，它是错误的
因为这是个迭代的死循环。
在new A()的时候，又会执行一遍A a= new A();
然后该new A()又执行一遍A a= new A();
如此往复，直到堆栈溢出。
当然 以下写法是正确的
public class A{
A a=null;
}
嗯，事实上，有些专门的写法，如单例，工厂类，就是需要在某个类里面实例化它本身。这个，楼主等你基础打好了，再研究吧。

