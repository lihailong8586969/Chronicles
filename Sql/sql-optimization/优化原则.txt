

原则 :
0）一般都是对 WHERE子句 进行优化
1) 尽量不让 SQL 进行全表扫描 .
2) 在 WHERE 和 ORDER BY 等涉及的列上建立索引
3) 不要在 WHERE 子句中使用表达式或者函数 , 否则将进行全表扫描
4) EXPLAIN SQL 是分析SQL的工具
5)


1、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。


2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。


3、不要在 WHERE子句中 使用表达式 , 如 select id from t where num/2=100 , 将进行全表扫描


4、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。

5、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

6、禁止 NULL值 比较(全表扫描) , 一定要设置字段 NOT NULL 并设置默认值 , 在查询的时候 , 不要使用 WHERE IS NOT NULL , 否则将会全表查询

7、尽量设置字段类型为数字类型 ，因为数字类型的匹配速度 远远大于 字符串

8、只要一行数据时尽量使用limit 1

9、绝对不要轻易用order by rand(),很可能会导致mysql的灾难

10、每个表都应该设置一个ID主键，最好的是一个INT型，并且设置上自动增加的AUTO_INCREMENT标志，这点其实应该作为设计表结构的第一件必然要做的事！

11、注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。

12、LIKE 模糊查询效率太低 , 使用变通的方法去解决 .
SELECT * FROM A WHERE `name` LIKE 'mysql%';
SELECT * FROM A WHERE `name` >= 'mysql' AND `name` < 'MySQM';


